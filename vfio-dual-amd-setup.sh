#!/usr/bin/env bash
set -euo pipefail

# vfio-dual-amd-setup.sh
# Interactive dual-AMD-GPU passthrough helper.
# - DOES NOT blacklist amdgpu or snd_hda_intel
# - Binds ONLY the selected GPU's PCI BDFs (GPU + its HDMI audio) to vfio-pci
# - Avoids the common pitfall where both AMD HDMI audio functions share the same PCI ID (e.g. 1002:ab28)
#
# Tested assumptions:
# - systemd
# - GRUB in /etc/default/grub
# - lspci available

SCRIPT_NAME="$(basename "$0")"
CONF_FILE="/etc/vfio-dual-amd.conf"
BIND_SCRIPT="/usr/local/sbin/vfio-bind-selected-amd.sh"
AUDIO_SCRIPT="/usr/local/bin/vfio-set-host-hdmi-audio.sh"
SYSTEMD_UNIT="/etc/systemd/system/vfio-bind-selected-amd.service"
MODULES_LOAD="/etc/modules-load.d/vfio.conf"

say() { printf '%s\n' "$*"; }
die() { say "ERROR: $*" >&2; exit 1; }

need_cmd() {
  command -v "$1" >/dev/null 2>&1 || die "Missing required command: $1"
}

require_root() {
  if [[ "${EUID:-$(id -u)}" -ne 0 ]]; then
    if command -v sudo >/dev/null 2>&1; then
      exec sudo -E "$0" "$@"
    fi
    die "Run as root (or install sudo)."
  fi
}

backup_file() {
  local f="$1"
  [[ -f "$f" ]] || return 0
  local ts
  ts="$(date +%Y%m%d-%H%M%S)"
  cp -a "$f" "${f}.bak.${ts}"
}

trim() {
  local s="$1"
  # shellcheck disable=SC2001
  s="$(echo "$s" | sed -e 's/^[[:space:]]\+//' -e 's/[[:space:]]\+$//')"
  printf '%s' "$s"
}

# ---------------- GPU discovery ----------------

gpu_discover() {
  # Emits one tab-separated record per AMD GPU:
  # GPU_BDF \t GPU_DESC \t GPU_ID \t AUDIO_BDF \t AUDIO_DESC \t AUDIO_ID
  local line bdf slot desc id audio_bdf audio_line audio_desc audio_id

  # Match common display classes and AMD vendor strings.
  while IFS= read -r line; do
    bdf="$(awk '{print $1}' <<<"$line")"
    desc="$(cut -d']' -f2- <<<"$line" | sed 's/^: *//')"
    id="$(grep -oE '\[[0-9a-f]{4}:[0-9a-f]{4}\]' <<<"$line" | head -n1 | tr -d '[]')"

    slot="${bdf%.*}"
    audio_bdf="${slot}.1"
    audio_line=""
    audio_desc=""
    audio_id=""

    if lspci -Dnn -s "$audio_bdf" 2>/dev/null | grep -qi 'Audio device'; then
      audio_line="$(lspci -Dnn -s "$audio_bdf")"
      audio_desc="$(cut -d']' -f2- <<<"$audio_line" | sed 's/^: *//')"
      audio_id="$(grep -oE '\[[0-9a-f]{4}:[0-9a-f]{4}\]' <<<"$audio_line" | head -n1 | tr -d '[]')"
    else
      audio_bdf=""
    fi

    printf '%s\t%s\t%s\t%s\t%s\t%s\n' \
      "$bdf" "$(trim "$desc")" "$id" \
      "$audio_bdf" "$(trim "$audio_desc")" "$audio_id"
  done < <(
    lspci -Dnn | awk '
      /(VGA compatible controller|3D controller|Display controller)/ &&
      /(Advanced Micro Devices|AMD\/ATI)/ {print}
    '
  )
}

select_from_list() {
  local prompt="$1"; shift
  local -a options=("$@")
  local idx

  while true; do
    say "$prompt"
    for i in "${!options[@]}"; do
      say "  [$((i+1))] ${options[$i]}"
    done
    printf 'Enter number: '
    read -r idx
    [[ "$idx" =~ ^[0-9]+$ ]] || { say "Invalid number"; continue; }
    (( idx >= 1 && idx <= ${#options[@]} )) || { say "Out of range"; continue; }
    echo "$((idx-1))"
    return 0
  done
}

# ---------------- Config write ----------------

write_conf() {
  local host_gpu="$1" host_audio="$2" guest_gpu="$3" guest_audio="$4"

  backup_file "$CONF_FILE"
  cat >"$CONF_FILE" <<EOF
# Generated by $SCRIPT_NAME on $(date -Is)
#
# IMPORTANT: We store PCI addresses (BDF), NOT only vendor:device IDs.
# That avoids accidentally capturing BOTH HDMI audio functions when they share the same PCI ID
# (e.g. both AMD HDMI audio controllers show as 1002:ab28).

HOST_GPU_BDF="$host_gpu"
HOST_AUDIO_BDF="$host_audio"
GUEST_GPU_BDF="$guest_gpu"
GUEST_AUDIO_BDF="$guest_audio"
EOF

  chmod 0644 "$CONF_FILE"
}

# ---------------- GRUB / kernel params ----------------

grub_add_kernel_params() {
  local params_to_add=("amd_iommu=on" "iommu=pt")

  [[ -f /etc/default/grub ]] || die "/etc/default/grub not found"
  backup_file /etc/default/grub

  # Prefer GRUB_CMDLINE_LINUX_DEFAULT, fall back to GRUB_CMDLINE_LINUX.
  local key
  if grep -q '^GRUB_CMDLINE_LINUX_DEFAULT=' /etc/default/grub; then
    key='GRUB_CMDLINE_LINUX_DEFAULT'
  elif grep -q '^GRUB_CMDLINE_LINUX=' /etc/default/grub; then
    key='GRUB_CMDLINE_LINUX'
  else
    die "Could not find GRUB_CMDLINE_LINUX_DEFAULT or GRUB_CMDLINE_LINUX in /etc/default/grub"
  fi

  local current
  current="$(grep -E "^${key}=" /etc/default/grub | head -n1 | sed -E "s/^${key}=(\"|')(.*)(\"|')\s*$/\2/")"

  local new="$current"
  local p
  for p in "${params_to_add[@]}"; do
    if ! grep -qw "$p" <<<"$new"; then
      new="$new $p"
    fi
  done
  new="$(trim "$new")"

  # Replace the line in-place.
  perl -0777 -i -pe "s/^${key}=([\"']).*?\1/${key}=\"$new\"/m" /etc/default/grub

  if command -v update-grub >/dev/null 2>&1; then
    say "Updating GRUB config via update-grub..."
    update-grub
  elif command -v grub-mkconfig >/dev/null 2>&1; then
    # Common paths; distro-specific.
    local out
    if [[ -d /boot/grub ]]; then
      out=/boot/grub/grub.cfg
    elif [[ -d /boot/grub2 ]]; then
      out=/boot/grub2/grub.cfg
    else
      die "Could not determine grub.cfg output path (no /boot/grub or /boot/grub2)"
    fi
    say "Updating GRUB config via grub-mkconfig -o $out ..."
    grub-mkconfig -o "$out"
  else
    die "Neither update-grub nor grub-mkconfig found"
  fi
}

maybe_update_initramfs() {
  # Not strictly required for the systemd binding approach, but helps ensure vfio-pci is available early.
  if command -v update-initramfs >/dev/null 2>&1 && [[ -d /etc/initramfs-tools ]]; then
    say "Updating initramfs via update-initramfs -u ..."
    update-initramfs -u
    return 0
  fi

  if command -v dracut >/dev/null 2>&1; then
    say "Updating initramfs via dracut -f ..."
    dracut -f
    return 0
  fi

  say "NOTE: No initramfs update tool detected (update-initramfs or dracut). Skipping."
}

# ---------------- VFIO binding service ----------------

install_vfio_modules_load() {
  backup_file "$MODULES_LOAD"
  cat >"$MODULES_LOAD" <<'EOF'
# Load VFIO modules at boot (no AMD driver blacklisting)
vfio
vfio_pci
vfio_iommu_type1
vfio_virqfd
EOF
  chmod 0644 "$MODULES_LOAD"
}

install_bind_script() {
  backup_file "$BIND_SCRIPT"
  cat >"$BIND_SCRIPT" <<'EOF'
#!/usr/bin/env bash
set -euo pipefail

CONF_FILE="/etc/vfio-dual-amd.conf"

say() { printf '%s\n' "$*"; }

[[ -f "$CONF_FILE" ]] || { say "Missing $CONF_FILE" >&2; exit 1; }
# shellcheck disable=SC1090
. "$CONF_FILE"

# Sanity
: "${GUEST_GPU_BDF:?}"
: "${GUEST_AUDIO_BDF:?}"

modprobe vfio
modprobe vfio-pci
modprobe vfio_iommu_type1

bind_one() {
  local dev="$1"
  local sys="/sys/bus/pci/devices/$dev"
  [[ -d "$sys" ]] || { say "WARN: $dev not present in sysfs"; return 0; }

  # If bound, unbind from current driver.
  if [[ -L "$sys/driver" ]]; then
    local drv
    drv="$(basename "$(readlink "$sys/driver")")"
    if [[ -w "/sys/bus/pci/drivers/$drv/unbind" ]]; then
      echo "$dev" >"/sys/bus/pci/drivers/$drv/unbind" || true
    fi
  fi

  # Override and bind.
  echo vfio-pci >"$sys/driver_override"
  echo "$dev" >"/sys/bus/pci/drivers/vfio-pci/bind" || true
}

# Bind guest GPU + its HDMI audio. NOTE: we do NOT bind by vendor:device ID.
bind_one "$GUEST_GPU_BDF"
bind_one "$GUEST_AUDIO_BDF"

# Clear override for host HDMI audio (belt-and-suspenders)
if [[ -n "${HOST_AUDIO_BDF:-}" && -d "/sys/bus/pci/devices/$HOST_AUDIO_BDF" ]]; then
  echo "" >"/sys/bus/pci/devices/$HOST_AUDIO_BDF/driver_override" || true
fi

say "vfio-pci binding complete: $GUEST_GPU_BDF $GUEST_AUDIO_BDF"
EOF
  chmod 0755 "$BIND_SCRIPT"
}

install_systemd_unit() {
  backup_file "$SYSTEMD_UNIT"
  cat >"$SYSTEMD_UNIT" <<EOF
[Unit]
Description=Bind selected AMD GPU (and its HDMI audio) to vfio-pci for passthrough
DefaultDependencies=yes
After=systemd-modules-load.service
Before=display-manager.service
Before=libvirtd.service
Before=virtqemud.service
Before=multi-user.target

[Service]
Type=oneshot
ExecStart=$BIND_SCRIPT
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
EOF
  chmod 0644 "$SYSTEMD_UNIT"

  systemctl daemon-reload
  systemctl enable vfio-bind-selected-amd.service
}

# ---------------- Host audio default (PipeWire/WirePlumber) ----------------

install_audio_script() {
  backup_file "$AUDIO_SCRIPT"
  cat >"$AUDIO_SCRIPT" <<'EOF'
#!/usr/bin/env bash
set -euo pipefail

CONF_FILE="/etc/vfio-dual-amd.conf"

[[ -f "$CONF_FILE" ]] || exit 0
# shellcheck disable=SC1090
. "$CONF_FILE"

: "${HOST_AUDIO_BDF:?}"

# Convert 0000:06:00.1 -> pci-0000_06_00.1
pci_tag="$(echo "$HOST_AUDIO_BDF" | sed -E 's/^0000:/pci-0000_/; s/:/_/g')"

# Prefer PipeWire control if available.
if command -v wpctl >/dev/null 2>&1; then
  # Collect sink IDs from wpctl status.
  mapfile -t sink_ids < <(
    wpctl status | awk '
      /Sinks:/{in=1;next}
      /Sources:/{in=0}
      in{
        for(i=1;i<=NF;i++){
          if($i ~ /^[0-9]+\.$/){ gsub("\\.","",$i); print $i; break }
        }
      }
    '
  )

  for id in "${sink_ids[@]}"; do
    if wpctl inspect "$id" 2>/dev/null | grep -Fq "$pci_tag"; then
      wpctl set-default "$id" || true
      exit 0
    fi
  done

  exit 0
fi

# PulseAudio fallback
if command -v pactl >/dev/null 2>&1; then
  # Find sink name containing the PCI tag.
  sink_name="$(pactl list short sinks | awk -v tag="$pci_tag" '$0 ~ tag {print $2; exit}')"
  if [[ -n "$sink_name" ]]; then
    pactl set-default-sink "$sink_name" || true
  fi
fi
EOF
  chmod 0755 "$AUDIO_SCRIPT"
}

install_user_audio_unit() {
  # Install for the invoking user (SUDO_USER when script was run via sudo).
  local user="${SUDO_USER:-}"
  [[ -n "$user" ]] || { say "Skipping user audio unit (no SUDO_USER)"; return 0; }

  local home
  home="$(getent passwd "$user" | cut -d: -f6)"
  [[ -n "$home" && -d "$home" ]] || { say "Skipping user audio unit (no home for $user)"; return 0; }

  local unit_dir="$home/.config/systemd/user"
  local unit_path="$unit_dir/vfio-set-host-hdmi-audio.service"

  mkdir -p "$unit_dir"

  cat >"$unit_path" <<EOF
[Unit]
Description=Set PipeWire/PulseAudio default sink to host GPU HDMI audio (avoid VFIO grabbing it)
After=pipewire.service wireplumber.service

[Service]
Type=oneshot
ExecStart=$AUDIO_SCRIPT

[Install]
WantedBy=default.target
EOF

  chown -R "$user:$user" "$home/.config/systemd"

  # Enable for user (best-effort). Requires user session; doesn't fail the install.
  runuser -u "$user" -- systemctl --user daemon-reload || true
  runuser -u "$user" -- systemctl --user enable vfio-set-host-hdmi-audio.service || true
}

# ---------------- Main ----------------

main() {
  need_cmd lspci
  need_cmd systemctl
  need_cmd modprobe

  require_root "$@"

  say "\nDual-AMD VFIO setup (no AMD driver blacklisting)"
  say "This tool binds ONLY the selected GPU + its HDMI audio function by PCI address (BDF)."
  say "This avoids the 1002:ab28 pitfall (both AMD HDMI audio devices share the same ID)."
  say

  # Turn discovery records into arrays.
  local -a gpu_bdfs=() gpu_descs=() audio_bdfs=() audio_descs=()
  local gpu_bdf gpu_desc _gpu_id audio_bdf audio_desc _audio_id
  while IFS=$'\t' read -r gpu_bdf gpu_desc _gpu_id audio_bdf audio_desc _audio_id; do
    [[ -n "${gpu_bdf:-}" ]] || continue
    gpu_bdfs+=("$gpu_bdf")
    gpu_descs+=("$gpu_desc")
    audio_bdfs+=("$audio_bdf")
    audio_descs+=("$audio_desc")
  done < <(gpu_discover)

  if (( ${#gpu_bdfs[@]} < 2 )); then
    die "Found fewer than 2 AMD GPUs. Need dual GPU for this script."
  fi

  local -a options=()
  local i
  for i in "${!gpu_bdfs[@]}"; do
    options+=("${gpu_bdfs[$i]}  ::  ${gpu_descs[$i]}  (audio: ${audio_bdfs[$i]} :: ${audio_descs[$i]})")
  done

  local guest_idx host_idx
  guest_idx="$(select_from_list "Select the GPU to PASSTHROUGH (bind to vfio-pci):" "${options[@]}")"

  # If exactly 2, infer host as the other; else ask.
  if (( ${#gpu_bdfs[@]} == 2 )); then
    if (( guest_idx == 0 )); then host_idx=1; else host_idx=0; fi
  else
    host_idx="$(select_from_list "Select the GPU to use for HOST display/sound:" "${options[@]}")"
    if (( host_idx == guest_idx )); then
      die "Host GPU and guest GPU cannot be the same."
    fi
  fi

  local guest_gpu guest_audio host_gpu host_audio
  guest_gpu="${gpu_bdfs[$guest_idx]}"
  guest_audio="${audio_bdfs[$guest_idx]}"
  host_gpu="${gpu_bdfs[$host_idx]}"
  host_audio="${audio_bdfs[$host_idx]}"

  [[ -n "$guest_audio" ]] || die "Could not find HDMI audio function (.1) for guest GPU; aborting"
  [[ -n "$host_audio" ]] || die "Could not find HDMI audio function (.1) for host GPU; aborting"

  say "\nSummary:"
  say "  Host GPU : $host_gpu"
  say "  Host HDMI audio: $host_audio (THIS MUST STAY ENABLED)"
  say "  Guest GPU: $guest_gpu"
  say "  Guest HDMI audio: $guest_audio (will be bound to vfio-pci)"
  say

  printf 'Proceed and write system config? [y/N] '
  local ans
  read -r ans
  [[ "$ans" =~ ^[Yy]$ ]] || die "Aborted by user"

  write_conf "$host_gpu" "$host_audio" "$guest_gpu" "$guest_audio"

  install_vfio_modules_load
  install_bind_script
  install_systemd_unit

  say "\nAdd IOMMU kernel parameters to GRUB (amd_iommu=on iommu=pt)? [Y/n] "
  read -r ans
  if [[ ! "$ans" =~ ^[Nn]$ ]]; then
    grub_add_kernel_params
  fi

  say "\nUpdate initramfs now? (recommended) [Y/n] "
  read -r ans
  if [[ ! "$ans" =~ ^[Nn]$ ]]; then
    maybe_update_initramfs
  fi

  say "\nInstall a user systemd unit to re-select host HDMI audio after login? [Y/n] "
  read -r ans
  if [[ ! "$ans" =~ ^[Nn]$ ]]; then
    install_audio_script
    install_user_audio_unit
  fi

  say "\nDone. Next steps:"
  say "  1) Reboot."
  say "  2) Verify guest GPU is bound to vfio-pci:"
  say "       lspci -nnk -s $guest_gpu"
  say "       lspci -nnk -s $guest_audio"
  say "     Host HDMI audio should remain on snd_hda_intel:"
  say "       lspci -nnk -s $host_audio"
  say "  3) In your VM manager, passthrough BOTH $guest_gpu and $guest_audio."
}

main "$@"
